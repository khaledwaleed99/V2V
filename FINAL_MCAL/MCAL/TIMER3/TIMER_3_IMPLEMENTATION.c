/*
 * TIMER_3_IMPLEMENTATION.c
 *
 * Created: 11/28/2023 3:07:24 PM
 *  Author: khaled waleed
 */ 


#include "TIMER_3_PROTOTYPES.h"
#include "DIO_PROTOTYPES.h"

/*
 GLOBAL VARIABLS WILL BE NEEDED FOR CALCULAIONS
*/

// FOR NORMAL MODE

uint32 NUM_OVER_FLOW_TIMER_3 = 0;
uint32 STARTING_TICK_VALUE_TIMER_3 = 0;

// FOR CTC MODE

uint32 COMPARE_MATCH_CTC_TIMER_3 =0;


void TIMER_3_INT (void)
{
	/*
	 MODE OF OPERATION SELECTION
	*/
	
	#if TIMER_3_MODE_OF_OPERATION == TIMER_3_NORMAL_MODE 
	
	CLR_BIT (TCCR3A, DIO_PIN0);
	CLR_BIT (TCCR3A, DIO_PIN1);
	CLR_BIT (TCCR3B, DIO_PIN3);
	CLR_BIT (TCCR3B, DIO_PIN4);
	
	#elif TIMER_3_MODE_OF_OPERATION == TIMER_3_PWM_PHASE_CORRET_8_BIT_MODE
	
	SET_BIT (TCCR3A, DIO_PIN0);
	CLR_BIT (TCCR3A, DIO_PIN1);
	CLR_BIT (TCCR3B, DIO_PIN3);
	CLR_BIT (TCCR3B, DIO_PIN4);
	
	#elif TIMER_3_MODE_OF_OPERATION == TIMER_3_PWM_PHASE_CORRET_9_BIT_MODE
	
	CLR_BIT (TCCR3A, DIO_PIN0);
	SET_BIT (TCCR3A, DIO_PIN1);
	CLR_BIT (TCCR3B, DIO_PIN3);
	CLR_BIT (TCCR3B, DIO_PIN4);
	
	#elif TIMER_3_MODE_OF_OPERATION == TIMER_3_PWM_PHASE_CORRET_10_BIT_MODE
	
	SET_BIT (TCCR3A, DIO_PIN0);
	SET_BIT (TCCR3A, DIO_PIN1);
	CLR_BIT (TCCR3B, DIO_PIN3);
	CLR_BIT (TCCR3B, DIO_PIN4);
	
	#elif TIMER_3_MODE_OF_OPERATION == TIMER_3_CTC_MODE_OCR3A
	
	CLR_BIT (TCCR3A, DIO_PIN0);
	CLR_BIT (TCCR3A, DIO_PIN1);
	SET_BIT (TCCR3B, DIO_PIN3);
	CLR_BIT (TCCR3B, DIO_PIN4);
	
	#elif TIMER_3_MODE_OF_OPERATION == TIMER_3_FAST_PWM_8_BIT_MODE
	
	SET_BIT (TCCR3A, DIO_PIN0);
	CLR_BIT (TCCR3A, DIO_PIN1);
	SET_BIT (TCCR3B, DIO_PIN3);
	CLR_BIT (TCCR3B, DIO_PIN4);
	
	#elif TIMER_3_MODE_OF_OPERATION == TIMER_3_FAST_PWM_9_BIT_MODE
	
	CLR_BIT (TCCR3A, DIO_PIN0);
	SET_BIT (TCCR3A, DIO_PIN1);
	SET_BIT (TCCR3B, DIO_PIN3);
	CLR_BIT (TCCR3B, DIO_PIN4);
	
	#elif TIMER_3_MODE_OF_OPERATION == TIMER_3_FAST_PWM_10_BIT_MODE
	
	SET_BIT (TCCR3A, DIO_PIN0);
	SET_BIT (TCCR3A, DIO_PIN1);
	SET_BIT (TCCR3B, DIO_PIN3);
	CLR_BIT (TCCR3B, DIO_PIN4);
	
	#elif TIMER_3_MODE_OF_OPERATION == TIMER_3_PWM_PHASE_FREQU_CORRECT_ICR3
	
	CLR_BIT (TCCR3A, DIO_PIN0);
	CLR_BIT (TCCR3A, DIO_PIN1);
	CLR_BIT (TCCR3B, DIO_PIN3);
	SET_BIT (TCCR3B, DIO_PIN4);
	
	#elif TIMER_3_MODE_OF_OPERATION == TIMER_3_PWM_PHASE_FREQU_CORRECT_OCR3A
	
	SET_BIT (TCCR3A, DIO_PIN0);
	CLR_BIT (TCCR3A, DIO_PIN1);
	CLR_BIT (TCCR3B, DIO_PIN3);
	SET_BIT (TCCR3B, DIO_PIN4);
	
	#elif TIMER_3_MODE_OF_OPERATION == TIMER_3_PWM_PHASE_CORRECT_ICR3
	
	CLR_BIT (TCCR3A, DIO_PIN0);
	SET_BIT (TCCR3A, DIO_PIN1);
	CLR_BIT (TCCR3B, DIO_PIN3);
	SET_BIT (TCCR3B, DIO_PIN4);
	
	#elif TIMER_3_MODE_OF_OPERATION == TIMER_3_PWM_PHASE_CORRECT_OCR3A
	
	SET_BIT (TCCR3A, DIO_PIN0);
	SET_BIT (TCCR3A, DIO_PIN1);
	CLR_BIT (TCCR3B, DIO_PIN3);
	SET_BIT (TCCR3B, DIO_PIN4);
	
	#elif TIMER_3_MODE_OF_OPERATION == TIMER_3_CTC_MODE_ICR3
	
	CLR_BIT (TCCR3A, DIO_PIN0);
	CLR_BIT (TCCR3A, DIO_PIN1);
	SET_BIT (TCCR3B, DIO_PIN3);
	SET_BIT (TCCR3B, DIO_PIN4);
	
	#elif TIMER_3_MODE_OF_OPERATION == TIMER_3_CTC_MODE_ICR3
	
	CLR_BIT (TCCR3A, DIO_PIN0);
	CLR_BIT (TCCR3A, DIO_PIN1);
	SET_BIT (TCCR3B, DIO_PIN3);
	SET_BIT (TCCR3B, DIO_PIN4);
	
	#elif TIMER_3_MODE_OF_OPERATION == TIMER_3_REVERSED_MODE
	
	SET_BIT (TCCR3A, DIO_PIN0);
	CLR_BIT (TCCR3A, DIO_PIN1);
	SET_BIT (TCCR3B, DIO_PIN3);
	SET_BIT (TCCR3B, DIO_PIN4);
	
	#elif TIMER_3_MODE_OF_OPERATION == TIMER_3_FAST_PWM_MODE_ICR3
	
	DIO_SET_PIN_DIREC( TIMER_3_DIO_PORT , TIMER_3_DIO_PIN_OC3A , DIO_OUTPUT);
	
	CLR_BIT (TCCR3A, DIO_PIN0);
	SET_BIT (TCCR3A, DIO_PIN1);
	SET_BIT (TCCR3B, DIO_PIN3);
	SET_BIT (TCCR3B, DIO_PIN4);
	
	#if TIMER_3_FAST_PWM_STATE  == TIMER_3_FAST_PWM_MODE_NON_INVERTED
	
	CLR_BIT (TCCR3A, DIO_PIN6);
	SET_BIT (TCCR3A, DIO_PIN7);
	
	DIO_SET_PIN_VALUE( TIMER_3_DIO_PORT , TIMER_3_DIO_PIN_OC3A , DIO_HIGH);
	
	#elif TIMER_3_FAST_PWM_STATE  == TIMER_3_FAST_PWM_MODE_INVERTED
	
	SET_BIT (TCCR3A, DIO_PIN6);
	SET_BIT (TCCR3A, DIO_PIN7);
	
	DIO_SET_PORT_VALUE( TIMER_3_DIO_PORT , TIMER_3_DIO_PIN_OC3A , DIO_LOW);
	
	#endif
	
	#elif TIMER_3_MODE_OF_OPERATION == TIMER_3_FAST_PWM_MODE_OCR3A
	
	SET_BIT (TCCR3A, DIO_PIN0);
	SET_BIT (TCCR3A, DIO_PIN1);
	SET_BIT (TCCR3B, DIO_PIN3);
	SET_BIT (TCCR3B, DIO_PIN4);
	
	#endif
	
	/*
	 INTERRUPT STATE 
	*/
	
	#if TIMER_3_INTERRUPT_STATE  == TIMER_3_INTERRUPT_ENEBLE
	
	SET_BIT (SREG , DIO_PIN7);  // GLOBAL INTERRUPT
	
	#if TIMER_3_WANTED_INTERRUPT == TIMER_3_COMPARE_MATCH_A_INTERRUPT
	
	SET_BIT (ETIMSK ,DIO_PIN4);  
	
	#elif TIMER_3_WANTED_INTERRUPT == TIMER_3_COMPARE_MATCH_B_INTERRUPT
	
	SET_BIT (ETIMSK ,DIO_PIN3);
	
	#elif TIMER_3_WANTED_INTERRUPT == TIMER_3_OVER_FLOW_INTERRUPT
	
	SET_BIT (ETIMSK ,DIO_PIN2);
	
	#elif TIMER_3_WANTED_INTERRUPT == TIMER_3_ICU_INTERRUPT
	
	SET_BIT (ETIMSK ,DIO_PIN5);
	
	#endif
	
	#endif
	
	
	
	
}


void TIMER_3_START (void)
{
	/*
	 STATING THE PRE-SCALLER VALUE 
	*/
	
	#if TIMER_3_PRE_SCALLER_VALUE == TIMER_3_PRE_SCALLER_DIV_NO
	
	SET_BIT(TCCR3B , DIO_PIN0);
	CLR_BIT(TCCR3B , DIO_PIN1);
	CLR_BIT(TCCR3B , DIO_PIN2);
	
	#elif TIMER_3_PRE_SCALLER_VALUE == TIMER_3_PRE_SCALLER_DIV_8
	
	CLR_BIT(TCCR3B , DIO_PIN0);
	SET_BIT(TCCR3B , DIO_PIN1);
	CLR_BIT(TCCR3B , DIO_PIN2);
	
	#elif TIMER_3_PRE_SCALLER_VALUE == TIMER_3_PRE_SCALLER_DIV_64
	
	SET_BIT(TCCR3B , DIO_PIN0);
	SET_BIT(TCCR3B , DIO_PIN1);
	CLR_BIT(TCCR3B , DIO_PIN2);
	
	#elif TIMER_3_PRE_SCALLER_VALUE == TIMER_3_PRE_SCALLER_DIV_256
	
	CLR_BIT(TCCR3B , DIO_PIN0);
	CLR_BIT(TCCR3B , DIO_PIN1);
	SET_BIT(TCCR3B , DIO_PIN2);
	
	#elif TIMER_3_PRE_SCALLER_VALUE == TIMER_3_PRE_SCALLER_DIV_1024
	
	SET_BIT(TCCR3B , DIO_PIN0);
	CLR_BIT(TCCR3B , DIO_PIN1);
	SET_BIT(TCCR3B , DIO_PIN2);
	
	#endif
	
}


void TIMER_3_STOP (void)
{
	CLR_BIT ( TCCR3B,DIO_PIN0);
	CLR_BIT ( TCCR3B,DIO_PIN1);
	CLR_BIT ( TCCR3B,DIO_PIN2);
}


// TAKES TIME IN MILLI SEC //

void TIMER_3_SET_TIME (uint32 WANTED_TIME_MSEC)
{
	
	#if TIMER_3_MODE_OF_OPERATION == TIMER_3_NORMAL_MODE 
	
	/*
	 FNDING TIME FOR EACH TICK
	 
	 HERE WE DIVIDED BY 8 (NOT 8000000) .. JUST TO AVOID HAVING MANY ZEROS FOR NO REASON WITH UNIT8
	 
	 HERE THE VALUE WILL IN MICRO DIRCTLY
	*/
	
	uint8 TICK_TIME = ( TIMER_3_PRE_SCALLER_VALUE / 8 );   // = 128 micro sec ( pre= 1024)
	
	/*
	FINDING TOTAL NUMBER OF TICKS FOR A GIVEN TIME
	
	THE WANTED DELAY TIME IS MULTI BY 1000 TO CANGE IT FORM MILLI SECS TO MICRO
	*/
	
	uint32 TOTAL_TICKS = ( WANTED_TIME_MSEC * 1000 ) / TICK_TIME ;
	
	/*
	FINDING THE NUMBER OF OVER-FLOWS NEEDED
	
	65537 -> TO REACH OVER FLOW
	*/
	
	NUM_OVER_FLOW_TIMER_3 = TOTAL_TICKS / 65537 ;
	
	/*
	STARTING TICK VALUE FOR THE GIVEN TIME ( TO REACH THE FLAG TICK AT THE GIVEN TIME ) 
	*/
	
	STARTING_TICK_VALUE_TIMER_3 = 65537 - ( TOTAL_TICKS % 65537 );
	
	TCNT3L = STARTING_TICK_VALUE_TIMER_3 ;
	
	NUM_OVER_FLOW_TIMER_3 ++ ;
	
	
	#elif TIMER_3_MODE_OF_OPERATION == TIMER_3_CTC_MODE_OCR3A
	
		/*
		FNDING TIME FOR EACH TICK
		*/
		
		uint8 TICK_TIME = ( TIMER_3_PRE_SCALLER_VALUE / 8 ); // = 128 micro sec (pre = 1024)
			
		/*
		 FINDINH TOTAL NUMBER OF TICKS FOR A GIVEN TIME
		*/
		
		uint32 TOTAL_TICKS = ( WANTED_TIME_MSEC * 1000 ) / TICK_TIME ;
		
		TOTAL_TICKS = TOTAL_TICKS - 1; 
		
		if (TOTAL_TICKS < 65537)
		{
		OCR3AL = TOTAL_TICKS;
		COMPARE_MATCH_CTC_TIMER_3 = 1;
		}
		
		else   
		{
			//OCR3AL = 7812;
			
			COMPARE_MATCH_CTC_TIMER_3 = TOTAL_TICKS / 7812 ;
			
			STARTING_TICK_VALUE_TIMER_3 = ( TOTAL_TICKS % 7812 );  // deciemals 
	
			//COMPARE_MATCH_CTC_TIMER_3 = COMPARE_MATCH_CTC_TIMER_3 - STARTING_TICK_VALUE_TIMER_3 ;
			
			OCR3AL = 7812 - STARTING_TICK_VALUE_TIMER_3;
		}
		
		#endif
		
} 


void TIMER_3_SET_DUTY_CYCLE (uint8 DUTY_CYCLE)
{
	
	// SINCE , WE USE FAST PWM MODE WITH MODE NO.14 -> WE CAN STATE THE VALUE NEEDED FOR THE TOP : ICR3 = VALUE ; //
	
	ICR3L = 1024 ; // CHANGE BASED ON APPLICATIN USAGE 
	
	OCR3AL = ((DUTY_CYCLE * (ICR3L))/100) -1 ;
}


void TIMER_3_DUTY_CYCLE_START (void)
{
	/*
	 STATING THE PRE-SCALLER VALUE 
	*/
	
	#if TIMER_3_PRE_SCALLER_VALUE == TIMER_3_PRE_SCALLER_DIV_NO
	
	SET_BIT(TCCR3B , DIO_PIN0);
	CLR_BIT(TCCR3B , DIO_PIN1);
	CLR_BIT(TCCR3B , DIO_PIN2);
	
	#elif TIMER_3_PRE_SCALLER_VALUE == TIMER_3_PRE_SCALLER_DIV_8
	
	CLR_BIT(TCCR3B , DIO_PIN0);
	SET_BIT(TCCR3B , DIO_PIN1);
	CLR_BIT(TCCR3B , DIO_PIN2);
	
	#elif TIMER_3_PRE_SCALLER_VALUE == TIMER_3_PRE_SCALLER_DIV_64
	
	SET_BIT(TCCR3B , DIO_PIN0);
	SET_BIT(TCCR3B , DIO_PIN1);
	CLR_BIT(TCCR3B , DIO_PIN2);
	
	#elif TIMER_3_PRE_SCALLER_VALUE == TIMER_3_PRE_SCALLER_DIV_256
	
	CLR_BIT(TCCR3B , DIO_PIN0);
	CLR_BIT(TCCR3B , DIO_PIN1);
	SET_BIT(TCCR3B , DIO_PIN2);
	
	#elif TIMER_3_PRE_SCALLER_VALUE == TIMER_3_PRE_SCALLER_DIV_1024
	
	SET_BIT(TCCR3B , DIO_PIN0);
	CLR_BIT(TCCR3B , DIO_PIN1);
	SET_BIT(TCCR3B , DIO_PIN2);
	
	#endif
}