/*
 * TIMER_1_IMPLEMENTATION.c
 *
 * Created: 11/27/2023 9:42:38 PM
 *  Author: khaled waleed
 */ 


#include "TIMER_1_PROTOTYPES.h"
#include "DIO_PROTOTYPES.h"

/*
 GLOBAL VARIABLS WILL BE NEEDED FOR CALCULAIONS
*/

// FOR NORMAL MODE

uint32 NUM_OVER_FLOW_TIMER_1 = 0;
uint32 STARTING_TICK_VALUE_TIMER_1 = 0;

// FOR CTC MODE

uint32 COMPARE_MATCH_CTC_TIMER_1 =0;


void TIMER_1_INT (void)
{
	/*
	 MODE OF OPERATION SELECTION
	*/
	
	#if TIMER_1_MODE_OF_OPERATION == TIMER_1_NORMAL_MODE 
	
	CLR_BIT (TCCR1A, DIO_PIN0);
	CLR_BIT (TCCR1A, DIO_PIN1);
	CLR_BIT (TCCR1B, DIO_PIN3);
	CLR_BIT (TCCR1B, DIO_PIN4);
	
	#elif TIMER_1_MODE_OF_OPERATION == TIMER_1_PWM_PHASE_CORRET_8_BIT_MODE
	
	SET_BIT (TCCR1A, DIO_PIN0);
	CLR_BIT (TCCR1A, DIO_PIN1);
	CLR_BIT (TCCR1B, DIO_PIN3);
	CLR_BIT (TCCR1B, DIO_PIN4);
	
	#elif TIMER_1_MODE_OF_OPERATION == TIMER_1_PWM_PHASE_CORRET_9_BIT_MODE
	
	CLR_BIT (TCCR1A, DIO_PIN0);
	SET_BIT (TCCR1A, DIO_PIN1);
	CLR_BIT (TCCR1B, DIO_PIN3);
	CLR_BIT (TCCR1B, DIO_PIN4);
	
	#elif TIMER_1_MODE_OF_OPERATION == TIMER_1_PWM_PHASE_CORRET_10_BIT_MODE
	
	SET_BIT (TCCR1A, DIO_PIN0);
	SET_BIT (TCCR1A, DIO_PIN1);
	CLR_BIT (TCCR1B, DIO_PIN3);
	CLR_BIT (TCCR1B, DIO_PIN4);
	
	#elif TIMER_1_MODE_OF_OPERATION == TIMER_1_CTC_MODE_OCR1A
	
	CLR_BIT (TCCR1A, DIO_PIN0);
	CLR_BIT (TCCR1A, DIO_PIN1);
	SET_BIT (TCCR1B, DIO_PIN3);
	CLR_BIT (TCCR1B, DIO_PIN4);
	
	#elif TIMER_1_MODE_OF_OPERATION == TIMER_1_FAST_PWM_8_BIT_MODE
	
	SET_BIT (TCCR1A, DIO_PIN0);
	CLR_BIT (TCCR1A, DIO_PIN1);
	SET_BIT (TCCR1B, DIO_PIN3);
	CLR_BIT (TCCR1B, DIO_PIN4);
	
	#elif TIMER_1_MODE_OF_OPERATION == TIMER_1_FAST_PWM_9_BIT_MODE
	
	CLR_BIT (TCCR1A, DIO_PIN0);
	SET_BIT (TCCR1A, DIO_PIN1);
	SET_BIT (TCCR1B, DIO_PIN3);
	CLR_BIT (TCCR1B, DIO_PIN4);
	
	#elif TIMER_1_MODE_OF_OPERATION == TIMER_1_FAST_PWM_10_BIT_MODE
	
	SET_BIT (TCCR1A, DIO_PIN0);
	SET_BIT (TCCR1A, DIO_PIN1);
	SET_BIT (TCCR1B, DIO_PIN3);
	CLR_BIT (TCCR1B, DIO_PIN4);
	
	#elif TIMER_1_MODE_OF_OPERATION == TIMER_1_PWM_PHASE_FREQU_CORRECT_ICR1
	
	CLR_BIT (TCCR1A, DIO_PIN0);
	CLR_BIT (TCCR1A, DIO_PIN1);
	CLR_BIT (TCCR1B, DIO_PIN3);
	SET_BIT (TCCR1B, DIO_PIN4);
	
	#elif TIMER_1_MODE_OF_OPERATION == TIMER_1_PWM_PHASE_FREQU_CORRECT_OCR1A
	
	SET_BIT (TCCR1A, DIO_PIN0);
	CLR_BIT (TCCR1A, DIO_PIN1);
	CLR_BIT (TCCR1B, DIO_PIN3);
	SET_BIT (TCCR1B, DIO_PIN4);
	
	#elif TIMER_1_MODE_OF_OPERATION == TIMER_1_PWM_PHASE_CORRECT_ICR1
	
	CLR_BIT (TCCR1A, DIO_PIN0);
	SET_BIT (TCCR1A, DIO_PIN1);
	CLR_BIT (TCCR1B, DIO_PIN3);
	SET_BIT (TCCR1B, DIO_PIN4);
	
	#elif TIMER_1_MODE_OF_OPERATION == TIMER_1_PWM_PHASE_CORRECT_OCR1A
	
	SET_BIT (TCCR1A, DIO_PIN0);
	SET_BIT (TCCR1A, DIO_PIN1);
	CLR_BIT (TCCR1B, DIO_PIN3);
	SET_BIT (TCCR1B, DIO_PIN4);
	
	#elif TIMER_1_MODE_OF_OPERATION == TIMER_1_CTC_MODE_ICR1
	
	CLR_BIT (TCCR1A, DIO_PIN0);
	CLR_BIT (TCCR1A, DIO_PIN1);
	SET_BIT (TCCR1B, DIO_PIN3);
	SET_BIT (TCCR1B, DIO_PIN4);
	
	#elif TIMER_1_MODE_OF_OPERATION == TIMER_1_CTC_MODE_ICR1
	
	CLR_BIT (TCCR1A, DIO_PIN0);
	CLR_BIT (TCCR1A, DIO_PIN1);
	SET_BIT (TCCR1B, DIO_PIN3);
	SET_BIT (TCCR1B, DIO_PIN4);
	
	#elif TIMER_1_MODE_OF_OPERATION == TIMER_1_REVERSED_MODE
	
	SET_BIT (TCCR1A, DIO_PIN0);
	CLR_BIT (TCCR1A, DIO_PIN1);
	SET_BIT (TCCR1B, DIO_PIN3);
	SET_BIT (TCCR1B, DIO_PIN4);
	
	#elif TIMER_1_MODE_OF_OPERATION == TIMER_1_FAST_PWM_MODE_ICR1
	
	DIO_SET_PIN_DIREC( TIMER_1_DIO_PORT , TIMER_1_DIO_PIN_OC1A , DIO_OUTPUT);
	
	CLR_BIT (TCCR1A, DIO_PIN0);
	SET_BIT (TCCR1A, DIO_PIN1);
	SET_BIT (TCCR1B, DIO_PIN3);
	SET_BIT (TCCR1B, DIO_PIN4);
	
	#if TIMER_1_FAST_PWM_STATE  == TIMER_1_FAST_PWM_MODE_NON_INVERTED
	
	CLR_BIT (TCCR1A, DIO_PIN6);
	SET_BIT (TCCR1A, DIO_PIN7);
	
	DIO_SET_PIN_VALUE( TIMER_1_DIO_PORT , TIMER_1_DIO_PIN_OC1A , DIO_HIGH);
	
	#elif TIMER_1_FAST_PWM_STATE  == TIMER_1_FAST_PWM_MODE_INVERTED
	
	SET_BIT (TCCR1A, DIO_PIN6);
	SET_BIT (TCCR1A, DIO_PIN7);
	
	DIO_SET_PORT_VALUE( TIMER_1_DIO_PORT , TIMER_1_DIO_PIN_OC1A , DIO_LOW);
	
	#endif
	
	#elif TIMER_1_MODE_OF_OPERATION == TIMER_1_FAST_PWM_MODE_OCR1A
	
	SET_BIT (TCCR1A, DIO_PIN0);
	SET_BIT (TCCR1A, DIO_PIN1);
	SET_BIT (TCCR1B, DIO_PIN3);
	SET_BIT (TCCR1B, DIO_PIN4);
	
	#endif
	
	/*
	 INTERRUPT STATE 
	*/
	
	#if TIMER_1_INTERRUPT_STATE  == TIMER_1_INTERRUPT_ENEBLE
	
	SET_BIT (SREG , DIO_PIN7);  // GLOBAL INTERRUPT
	
	#if TIMER_1_WANTED_INTERRUPT == TIMER_1_COMPARE_MATCH_A_INTERRUPT
	
	SET_BIT (TIMSK ,DIO_PIN4);  
	
	#elif TIMER_1_WANTED_INTERRUPT == TIMER_1_COMPARE_MATCH_B_INTERRUPT
	
	SET_BIT (TIMSK ,DIO_PIN3);
	
	#elif TIMER_1_WANTED_INTERRUPT == TIMER_1_OVER_FLOW_INTERRUPT
	
	SET_BIT (TIMSK ,DIO_PIN2);
	
	#elif TIMER_1_WANTED_INTERRUPT == TIMER_1_ICU_INTERRUPT
	
	SET_BIT (TIMSK ,DIO_PIN5);
	
	#endif
	
	#endif
	
	
}


void TIMER_1_START (void)
{
	/*
	 STATING THE PRE-SCALLER VALUE 
	*/
	
	#if TIMER_1_PRE_SCALLER_VALUE == TIMER_1_PRE_SCALLER_DIV_NO
	
	SET_BIT(TCCR1B , DIO_PIN0);
	CLR_BIT(TCCR1B , DIO_PIN1);
	CLR_BIT(TCCR1B , DIO_PIN2);
	
	#elif TIMER_1_PRE_SCALLER_VALUE == TIMER_1_PRE_SCALLER_DIV_8
	
	CLR_BIT(TCCR1B , DIO_PIN0);
	SET_BIT(TCCR1B , DIO_PIN1);
	CLR_BIT(TCCR1B , DIO_PIN2);
	
	#elif TIMER_1_PRE_SCALLER_VALUE == TIMER_1_PRE_SCALLER_DIV_64
	
	SET_BIT(TCCR1B , DIO_PIN0);
	SET_BIT(TCCR1B , DIO_PIN1);
	CLR_BIT(TCCR1B , DIO_PIN2);
	
	#elif TIMER_1_PRE_SCALLER_VALUE == TIMER_1_PRE_SCALLER_DIV_256
	
	CLR_BIT(TCCR1B , DIO_PIN0);
	CLR_BIT(TCCR1B , DIO_PIN1);
	SET_BIT(TCCR1B , DIO_PIN2);
	
	#elif TIMER_1_PRE_SCALLER_VALUE == TIMER_1_PRE_SCALLER_DIV_1024
	
	SET_BIT(TCCR1B , DIO_PIN0);
	CLR_BIT(TCCR1B , DIO_PIN1);
	SET_BIT(TCCR1B , DIO_PIN2);
	
	#endif
	
}


void TIMER_1_STOP (void)
{
	CLR_BIT ( TCCR1B,DIO_PIN0);
	CLR_BIT ( TCCR1B,DIO_PIN1);
	CLR_BIT ( TCCR1B,DIO_PIN2);
}


// TAKES TIME IN MILLI SEC //

void TIMER_1_SET_TIME (uint32 WANTED_TIME_MSEC)
{
	
	#if TIMER_1_MODE_OF_OPERATION == TIMER_1_NORMAL_MODE 
	
	/*
	 FNDING TIME FOR EACH TICK
	 
	 HERE WE DIVIDED BY 8 (NOT 8000000) .. JUST TO AVOID HAVING MANY ZEROS FOR NO REASON WITH UNIT8
	 
	 HERE THE VALUE WILL IN MICRO DIRCTLY
	*/
	
	uint8 TICK_TIME = ( TIMER_1_PRE_SCALLER_VALUE / 8 );   // = 128 micro sec ( pre= 1024)
	
	/*
	FINDING TOTAL NUMBER OF TICKS FOR A GIVEN TIME
	
	THE WANTED DELAY TIME IS MULTI BY 1000 TO CANGE IT FORM MILLI SECS TO MICRO
	*/
	
	uint32 TOTAL_TICKS = ( WANTED_TIME_MSEC * 1000 ) / TICK_TIME ;
	
	/*
	FINDING THE NUMBER OF OVER-FLOWS NEEDED
	
	65537 -> TO REACH OVER FLOW
	*/
	
	NUM_OVER_FLOW_TIMER_1 = TOTAL_TICKS / 65537 ;
	
	/*
	STARTING TICK VALUE FOR THE GIVEN TIME ( TO REACH THE FLAG TICK AT THE GIVEN TIME ) 
	*/
	
	STARTING_TICK_VALUE_TIMER_1 = 65537 - ( TOTAL_TICKS % 65537 );
	
	TCNT1l = STARTING_TICK_VALUE_TIMER_1 ;
	
	NUM_OVER_FLOW_TIMER_1 ++ ;
	
	
	#elif TIMER_1_MODE_OF_OPERATION == TIMER_1_CTC_MODE_OCR1A
	
		/*
		FNDING TIME FOR EACH TICK
		*/
		
		uint8 TICK_TIME = ( TIMER_1_PRE_SCALLER_VALUE / 8 ); // = 128 micro sec (pre = 1024)
			
		/*
		 FINDINH TOTAL NUMBER OF TICKS FOR A GIVEN TIME
		*/
		
		uint32 TOTAL_TICKS = ( WANTED_TIME_MSEC * 1000 ) / TICK_TIME ;
		
		TOTAL_TICKS = TOTAL_TICKS - 1; 
		
		if (TOTAL_TICKS < 65537)
		{
		OCR1AL = TOTAL_TICKS;
		COMPARE_MATCH_CTC_TIMER_1 = 1;
		}
		
		else   
		{
			//OCR1AL = 7812;
			
			COMPARE_MATCH_CTC_TIMER_1 = TOTAL_TICKS / 7812 ;
			
			STARTING_TICK_VALUE_TIMER_1 = ( TOTAL_TICKS % 7812 );  // deciemals 
	
			//COMPARE_MATCH_CTC_TIMER_1 = COMPARE_MATCH_CTC_TIMER_1 - STARTING_TICK_VALUE_TIMER_1 ;
			
			OCR1AL = 7812 - STARTING_TICK_VALUE_TIMER_1;
		}
		
		#endif
		
} 


void TIMER_1_SET_DUTY_CYCLE (uint8 DUTY_CYCLE)
{
	
	// SINCE , WE USE FAST PWM MODE WITH MODE NO.14 -> WE CAN STATE THE VALUE NEEDED FOR THE TOP : ICR1 = VALUE ; //
	
	ICR1L = 1024 ; // CHANGE BASED ON APPLICATIN USAGE 
	
	OCR1AL = ((DUTY_CYCLE * (ICR1L))/100) -1 ;
}


void TIMER_1_DUTY_CYCLE_START (void)
{
	/*
	 STATING THE PRE-SCALLER VALUE 
	*/
	
	#if TIMER_1_PRE_SCALLER_VALUE == TIMER_1_PRE_SCALLER_DIV_NO
	
	SET_BIT(TCCR1B , DIO_PIN0);
	CLR_BIT(TCCR1B , DIO_PIN1);
	CLR_BIT(TCCR1B , DIO_PIN2);
	
	#elif TIMER_1_PRE_SCALLER_VALUE == TIMER_1_PRE_SCALLER_DIV_8
	
	CLR_BIT(TCCR1B , DIO_PIN0);
	SET_BIT(TCCR1B , DIO_PIN1);
	CLR_BIT(TCCR1B , DIO_PIN2);
	
	#elif TIMER_1_PRE_SCALLER_VALUE == TIMER_1_PRE_SCALLER_DIV_64
	
	SET_BIT(TCCR1B , DIO_PIN0);
	SET_BIT(TCCR1B , DIO_PIN1);
	CLR_BIT(TCCR1B , DIO_PIN2);
	
	#elif TIMER_1_PRE_SCALLER_VALUE == TIMER_1_PRE_SCALLER_DIV_256
	
	CLR_BIT(TCCR1B , DIO_PIN0);
	CLR_BIT(TCCR1B , DIO_PIN1);
	SET_BIT(TCCR1B , DIO_PIN2);
	
	#elif TIMER_1_PRE_SCALLER_VALUE == TIMER_1_PRE_SCALLER_DIV_1024
	
	SET_BIT(TCCR1B , DIO_PIN0);
	CLR_BIT(TCCR1B , DIO_PIN1);
	SET_BIT(TCCR1B , DIO_PIN2);
	
	#endif
}

